#!/usr/bin/env ruby

class Cli
  attr_reader :paths
  def initialize(args)
    @paths = Dir.glob(args)
  end

  def run
    process_each_path
  end

  def process_each_path
    paths.each do |path|
      puts Path.new(path).parse.to_s
    end
  end
end

class Path

  class PathMissingError < Exception
    def exit_status; 1 ; end
  end

  class UnparsablePlist < Exception
    def exit_status; 2 ; end
  end

  attr_reader :path

  def initialize(path)
    @path = path
  end

  def validate
    raise PathMissingError unless File.exist?(path)
  end

  def content
    PathContent.new(path).to_s
  end

  def parse
    begin
      path_parser.parse
    rescue
      raise UnparsablePlist
    end
  end

  def path_parser
    PathParser.new(self)
  end

end

class PathContent
  attr_reader :path
  def initialize(path)
    @path = path
  end

  def to_s
    if binary?
      `plutil -convert xml1 -o /dev/stdout '#{path}'`
    else
      File.read(path)
    end
  end

  def binary?
    f = File.open(path, "r")
    f.read(6) == "bplist"
  ensure
    f.close
  end
end

require 'rexml/document'
include REXML
class PathParser
  attr_reader :path, :xml_doc
  def initialize(path)
    @path = path
  end

  # returns a parsed launchd job
  def parse
    LaunchdJob.new({ 'EnvironmentVariables' => parse_env, 'ProgramArguments' => parse_program_args })
  end

  def parse_env
    variables = EnvironmentParser.new(xml_doc).parse
    EnvironmentVariables.new(variables).to_a
  end

  def parse_program_args
    ProgramArgsParser.new(xml_doc).parse
  end

  def xml_doc
    @xml_doc ||= Document.new(path.content)
  end

end

require 'rexml/document'
include REXML
class EnvironmentParser
  attr_reader :xml_doc, :element
  def initialize(xml_doc)
    @xml_doc = xml_doc
  end

  def element
    @element ||= REXML::XPath.first(xml_doc, "plist/dict/key[text()='EnvironmentVariables']/following-sibling::dict")
  end

  def extract_env
    env = {}
    REXML::XPath.match(element, 'key').each do |environment_key|
      env[environment_key.text] = environment_key.next_sibling.next_sibling.text
    end
    env
  end

  def parse
    if element
      extract_env
    else
      {}
    end
  end

end

class EnvironmentVariables
  attr_reader :variables
  def initialize(variables = {})
    @variables = variables
  end

  def to_a
    env_items = []
    variables.each do |key,value|
      env_items << "#{key}=#{value}"
    end
    env_items
  end
end

require 'rexml/document'
include REXML
class ProgramArgsParser
  attr_reader :xml_doc, :element
  def initialize(xml_doc)
    @xml_doc = xml_doc
  end

  def parse
    element = REXML::XPath.first(xml_doc, "plist/dict/key[text()='ProgramArguments']/following-sibling::array")
    if element
      args_strings = XPath.match(element, 'string')
      args_strings.map {|e| e.text }
    else
      program_string_element = REXML::XPath.first(xml_doc, "plist/dict/key[text()='Program']/following-sibling::string")
      [program_string_element.text]
    end
  end
end

class LaunchdJob
  attr_reader :attributes
  def initialize(attributes = {})
    @attributes = attributes
  end

  def environment_variables
    attributes.fetch('EnvironmentVariables', {})
  end

  def program_arguments
    attributes.fetch('ProgramArguments', [])
  end

  def to_s
    puts (environment_variables + program_arguments).join(" ")
  end
end


if __FILE__ == $0
  Cli.new(ARGV).run
end


